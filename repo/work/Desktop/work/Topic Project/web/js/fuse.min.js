/**
 * Fuse.js v6.6.2 - Lightweight fuzzy-search
 * https://github.com/krisk/Fuse
 * MIT License
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Fuse = t() }(this, (function () {
    "use strict"; function e(e, t) { var n = Object.keys(e); if (Object.getOwnPropertySymbols) { var r = Object.getOwnPropertySymbols(e); t && (r = r.filter((function (t) { return Object.getOwnPropertyDescriptor(e, t).enumerable }))), n.push.apply(n, r) } return n } function t(t) { for (var n = 1; n < arguments.length; n++) { var r = null != arguments[n] ? arguments[n] : {}; n % 2 ? e(Object(r), !0).forEach((function (e) { i(t, e, r[e]) })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : e(Object(r)).forEach((function (e) { Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e)) })) } return t } function n(e) { return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, n(e) } function r(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function o(e, t) { for (var n = 0; n < t.length; n++) { var r = t[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r) } } function c(e, t, n) { return t && o(e.prototype, t), n && o(e, n), Object.defineProperty(e, "prototype", { writable: !1 }), e } function i(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } function a(e, t) { if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function"); e.prototype = Object.create(t && t.prototype, { constructor: { value: e, writable: !0, configurable: !0 } }), Object.defineProperty(e, "prototype", { writable: !1 }), t && u(e, t) } function s(e) { return s = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) { return e.__proto__ || Object.getPrototypeOf(e) }, s(e) } function u(e, t) { return u = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) { return e.__proto__ = t, e }, u(e, t) } function f() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () { }))), !0 } catch (e) { return !1 } } function l(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e } function h(e, t) { if (t && ("object" == typeof t || "function" == typeof t)) return t; if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined"); return l(e) } function d(e) { var t = f(); return function () { var n, r = s(e); if (t) { var o = s(this).constructor; n = Reflect.construct(r, arguments, o) } else n = r.apply(this, arguments); return h(this, n) } } function v(e, t) { for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = s(e));); return e } function g() { return g = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, n) { var r = v(e, t); if (r) { var o = Object.getOwnPropertyDescriptor(r, t); return o.get ? o.get.call(arguments.length < 3 ? e : n) : o.value } }, g.apply(this, arguments) } function y(e, t) { return function (e) { if (Array.isArray(e)) return e }(e) || function (e, t) { var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"]; if (null == n) return; var r, o, c = [], i = !0, a = !1; try { for (n = n.call(e); !(i = (r = n.next()).done) && (c.push(r.value), !t || c.length !== t); i = !0); } catch (e) { a = !0, o = e } finally { try { i || null == n.return || n.return() } finally { if (a) throw o } } return c }(e, t) || m(e, t) || function () { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function p(e) { return function (e) { if (Array.isArray(e)) return b(e) }(e) || function (e) { if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e) }(e) || m(e) || function () { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.") }() } function m(e, t) { if (e) { if ("string" == typeof e) return b(e, t); var n = Object.prototype.toString.call(e).slice(8, -1); return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? b(e, t) : void 0 } } function b(e, t) { (null == t || t > e.length) && (t = e.length); for (var n = 0, r = new Array(t); n < t; n++)r[n] = e[n]; return r } function M(e) { return Array.isArray ? Array.isArray(e) : "[object Array]" === x(e) } function k(e) { return "string" == typeof e } function S(e) { return "number" == typeof e } function w(e) { return !0 === e || !1 === e || function (e) { return function (e) { return null != e }(e) && "object" === n(e) }(e) && "[object Boolean]" == x(e) } function x(e) { return null == e ? void 0 === e ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(e) } var L = function (e) { return !(!e || !k(e) && !S(e)) }, _ = { isCaseSensitive: !1, includeScore: !1, keys: [], shouldSort: !0, sortFn: function (e, t) { return e.score === t.score ? e.idx < t.idx ? -1 : 1 : e.score < t.score ? -1 : 1 }, includeMatches: !1, findAllMatches: !1, minMatchCharLength: 1, location: 0, threshold: .6, distance: 100, useExtendedSearch: !1, getFn: function (e, t) { var n = [], r = !1; return function e(t, o, c) { if (L(t)) if (o[c]) { var i = t[o[c]]; if (!L(i)) return; if (c === o.length - 1) { if (k(i)) n.push(function (e) { return e.normalize("NFD").replace(/[\u0300-\u036f]/g, "") }(i)); else if (M(i)) for (var a = 0, s = i.length; a < s; a += 1) { var u = i[a]; L(u) && n.push(function (e) { return e.normalize("NFD").replace(/[\u0300-\u036f]/g, "") }(u)) } } else M(i) ? r = !0 : e(i, o, c + 1) } else n.push(t) }(e, k(t) ? t.split(".") : t, 0), r ? n : n[0] }, ignoreLocation: !1, ignoreFieldNorm: !1, fieldNormWeight: 1 }; var O = function () { function e() { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = t.getFn, o = void 0 === n ? _.getFn : n, c = t.fieldNormWeight, i = void 0 === c ? _.fieldNormWeight : c; r(this, e), this.norm = function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 3, n = new Map, r = Math.pow(10, t); return { get: function (t) { var o = t.match(/\S+/g).length; if (n.has(o)) return n.get(o); var c = 1 / Math.pow(o, .5 * e), i = parseFloat(Math.round(c * r) / r); return n.set(o, i), i }, clear: function () { n.clear() } } }(i, 3), this.getFn = o, this.isCreated = !1, this.setIndexRecords() } return c(e, [{ key: "setSources", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.docs = e } }, { key: "setIndexRecords", value: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.records = e } }, { key: "setKeys", value: function () { var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []; this.keys = t, this._keysMap = {}, t.forEach((function (t, n) { e._keysMap[t.id] = n })) } }, { key: "create", value: function () { var e = this; !this.isCreated && this.docs.length && (this.isCreated = !0, k(this.docs[0]) ? this.docs.forEach((function (t, n) { e._addString(t, n) })) : this.docs.forEach((function (t, n) { e._addObject(t, n) })), this.norm.clear()) } }, { key: "add", value: function (e) { var t = this.size(); k(e) ? this._addString(e, t) : this._addObject(e, t) } }, { key: "removeAt", value: function (e) { this.records.splice(e, 1); for (var t = e, n = this.size(); t < n; t += 1)this.records[t].i -= 1 } }, { key: "getValueForItemAtKeyId", value: function (e, t) { return e[this._keysMap[t]] } }, { key: "size", value: function () { return this.records.length } }, { key: "_addString", value: function (e, t) { if (L(e)) { var n = { v: e, i: t, n: this.norm.get(e) }; this.records.push(n) } } }, { key: "_addObject", value: function (e, t) { var n = this, r = { i: t, $: {} }; this.keys.forEach((function (t, o) { var c = t.getFn ? t.getFn(e) : n.getFn(e, t.path); if (L(c)) if (M(c)) { for (var i = [], a = [{ nestedArrIndex: -1, value: c }]; a.length;) { var s = a.pop(), u = s.nestedArrIndex, f = s.value; if (L(f)) if (k(f)) { var l = { v: f, i: u, n: n.norm.get(f) }; i.push(l) } else M(f) && f.forEach((function (e, t) { a.push({ nestedArrIndex: t, value: e }) })) } r.$[o] = i } else if (k(c)) { var h = { v: c, n: n.norm.get(c) }; r.$[o] = h } })), this.records.push(r) } }, { key: "toJSON", value: function () { return { keys: this.keys, records: this.records } } }]), e }(); function j(e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.getFn, o = void 0 === r ? _.getFn : r, c = n.fieldNormWeight, i = void 0 === c ? _.fieldNormWeight : c, a = new O({ getFn: o, fieldNormWeight: i }); return a.setKeys(e.map(A)), a.setSources(t), a.create(), a } function A(e) { return { id: k(e) ? e : e.name, weight: k(e) ? 1 : e.weight || 1, getFn: k(e) || (t = e.getFn) ? t : null, path: k(e) ? e : e.name }; var t } function I(e, t, n) { return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e } var E = function () {
        function e(t) {
            var n = this; r(this, e), I(this, "query", null), I(this, "_fuzzy", ""), I(this, "_exact", ""), I(this, "_prefix", ""), I(this, "_suffix", ""), I(this, "_all", ""), I(this, "_logical", ""), "string" == typeof t ? (this.pattern = t, this.query = function (e) { return e.map((function (e) { return E.condition(e.search, n) })) }(function (e) { return e.trim().split(/ +/g) }(t))) : Array.isArray(t) && (this.pattern = "", t.forEach((function (e) { var t = e.$val; if (t) switch (e.$path) { case "$or": n._logical += "".concat(t, " "); break; case "$all": n._all += "".concat(t, " ") } })), this._logical = this._logical.trim(), this._all = this._all.trim(), this.query = function (e) {
                var t = []
                ; return e._all && t.push.apply(t, p(e._all.split(/ +/g).map((function (e) { return E.condition(e, E) })))), e._logical && e._logical.split("|").forEach((function (e) { var n = e.trim().split(/ +/g).map((function (e) { return E.condition(e, E) })); t.push({ $or: n }) })), t
            }(this))
        } return c(e, null, [{ key: "condition", value: function (e, t) { return t._fuzzy && e.startsWith(t._fuzzy) ? { $fuzzy: e.slice(t._fuzzy.length) } : t._exact && e.startsWith(t._exact) ? { $exact: e.slice(t._exact.length) } : t._prefix && e.startsWith(t._prefix) ? { $prefix: e.slice(t._prefix.length) } : t._suffix && e.startsWith(t._suffix) ? { $suffix: e.slice(t._suffix.length) } : e } }]), e
    }(); function C(e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = n.isCaseSensitive, o = void 0 === r ? _.isCaseSensitive : r, c = n.includeMatches, i = void 0 === c ? _.includeMatches : c, a = n.minMatchCharLength, s = void 0 === a ? _.minMatchCharLength : a, u = n.ignoreLocation, f = void 0 === u ? _.ignoreLocation : u, l = n.findAllMatches, h = void 0 === l ? _.findAllMatches : l, d = n.location, v = void 0 === d ? _.location : d, g = n.threshold, y = void 0 === g ? _.threshold : g, p = n.distance, m = void 0 === p ? _.distance : p; if (o || (t = t.toLowerCase()), e === t) return { isMatch: !0, score: 0, indices: [[0, t.length - 1]] }; if (!t) return { isMatch: !1, score: 1 }; var b, M, k, S, w = e.length, x = t.length, L = Math.max(0, Math.min(v, x)), O = y, j = L, A = s > 1 || i, I = A ? Array(x) : []; for (; (b = t.indexOf(e, j)) > -1;) { var E = F(e, { currentLocation: b, expectedLocation: L, distance: m, ignoreLocation: f }); if (O = Math.min(E, O), j = b + w, A) for (var C = 0; C < w;)I[b + C] = 1, C += 1 } j = -1; for (var P = [], W = 1, N = w + x, z = 1 << w - 1, T = 0; T < w; T += 1) { for (var K = 0, R = N; K < R;)F(e, { errors: T, currentLocation: L + R, expectedLocation: L, distance: m, ignoreLocation: f }) <= O ? K = R : N = R, R = Math.floor((N - K) / 2 + K); N = R; var B = Math.max(1, L - R + 1), D = h ? x : Math.min(L + R, x) + w, G = Array(D + 2); G[D + 1] = (1 << T) - 1; for (var H = D; H >= B; H -= 1) { var J = H - 1, Q = t.charAt(J); if (o || (Q = Q.toLowerCase()), Q === e.charAt(0) ? (S = 1, M || (M = {}), M[J] || (M[J] = 0), M[J] |= z) : S = 0, k = z & (M && M[J - 1] || 0) | S, G[H] = (G[H + 1] << 1 | 1) & k, T && (G[H] |= (P[H + 1] | P[H]) << 1 | 1 | P[H + 1]), G[H] & z && (W = F(e, { errors: T, currentLocation: J, expectedLocation: L, distance: m, ignoreLocation: f })) <= O) { if (O = W, (j = J) <= L) break; B = Math.max(1, 2 * L - j) } } if (F(e, { errors: T + 1, currentLocation: L, expectedLocation: L, distance: m, ignoreLocation: f }) > O) break; P = G } var U = { isMatch: j >= 0, score: Math.max(.001, W) }; if (A) { var V = $(I, s); V.length ? i && (U.indices = V) : U.isMatch = !1 } return U } function F(e, t) { var n = t.errors, r = void 0 === n ? 0 : n, o = t.currentLocation, c = void 0 === o ? 0 : o, i = t.expectedLocation, a = void 0 === i ? 0 : i, s = t.distance, u = void 0 === s ? _.distance : s, f = t.ignoreLocation, l = void 0 === f ? _.ignoreLocation : f, h = r / e.length; if (l) return h; var d = Math.abs(a - c); return u ? h + d / u : d ? 1 : h } function $(e, t) { for (var n = [], r = -1, o = -1, c = 0, i = e.length; c < i; c += 1) { var a = e[c]; a && -1 === r ? r = c : a || -1 === r || (o = c - 1, o - r + 1 >= t && n.push([r, o]), r = -1) } return e[i - 1] && i - r >= t && n.push([r, i - 1]), n } var P = function () {
        function e(t) {
            var n = this, o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c = o.isCaseSensitive, i = void 0 === c ? _.isCaseSensitive : c, a = o.includeMatches, s = void 0 === a ? _.includeMatches : a, u = o.minMatchCharLength, f = void 0 === u ? _.minMatchCharLength : u, l = o.ignoreLocation, h = void 0 === l ? _.ignoreLocation : l, d = o.findAllMatches, v = void 0 === d ? _.findAllMatches : d, g = o.location, y = void 0 === g ? _.location : g, p = o.threshold, m = void 0 === p ? _.threshold : p, b = o.distance, M = void 0 === b ? _.distance : b; r(this, e),
                this.options = { isCaseSensitive: i, includeMatches: s, minMatchCharLength: f, findAllMatches: v, ignoreLocation: h, location: y, threshold: m, distance: M }, this.pattern = i ? t : t.toLowerCase(), this.chunks = [], this.pattern && function e(t, r) { n.chunks.push({ pattern: t, alphabet: function (e) { for (var t = {}, n = 0, r = e.length; n < r; n += 1) { var o = e.charAt(n); t[o] = (t[o] || 0) | 1 << r - n - 1 } return t }(t), startIndex: r }), t.length > 32 && e(t.slice(32), r + 32) }(this.pattern, 0)
        } return c(e, [{ key: "searchIn", value: function (e) { var t = this.options, n = t.isCaseSensitive, r = t.includeMatches; if (n || (e = e.toLowerCase()), this.pattern === e) { var o = { isMatch: !0, score: 0 }; return r && (o.indices = [[0, e.length - 1]]), o } var c = this.options, i = c.location, a = c.distance, s = c.threshold, u = c.findAllMatches, f = c.minMatchCharLength, l = c.ignoreLocation, h = [], d = 0, v = !1; this.chunks.forEach((function (t) { var n = t.pattern, o = t.alphabet, c = t.startIndex, g = C(e, n, { location: i + c, distance: a, threshold: s, findAllMatches: u, minMatchCharLength: f, ignoreLocation: l, includeMatches: r }); g.isMatch && (v = !0), d += g.score, v && r && g.indices && h.push.apply(h, p(g.indices)) })); var g = { isMatch: v, score: v ? d / this.chunks.length : 1 }; return v && r && (g.indices = h), g } }]), e
    }(), W = function () { function e(t) { r(this, e), this.pattern = t } return c(e, [{ key: "search", value: function () { } }], [{ key: "isMultiMatch", value: function (e) { return N(e, this.multiRegex) } }, { key: "isSingleMatch", value: function (e) { return N(e, this.singleRegex) } }]), e }(); function N(e, t) { var n = e.match(t); return n ? n[1] : null } var z = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { for (var t = 0, n = !0, r = e.indexOf(this.pattern); -1 !== r;) { n = !1; var o = r + this.pattern.length; for (; r > -1 && e[r] !== " ";)r -= 1; if (r += 1, o - r >= this.pattern.length) { t += 1; var c = o; for (; c < e.length && " " !== e[c];)c += 1; if (0 === r || " " === e[r - 1]) if (c === e.length || " " === e[c]) return { isMatch: !0, score: 0, indices: [[r, c - 1]] } } r = e.indexOf(this.pattern, o) } return { isMatch: !n, score: t ? 1 : n ? 1 : 0 } } }], [{ key: "type", get: function () { return "exact" } }, { key: "multiRegex", get: function () { return /^="(.*)"$/ } }, { key: "singleRegex", get: function () { return /^=(.*)$/ } }]), n }(W), T = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = e === this.pattern; return { isMatch: t, score: t ? 0 : 1, indices: [0, this.pattern.length - 1] } } }], [{ key: "type", get: function () { return "exact" } }, { key: "multiRegex", get: function () { return /^"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^(.*)$/ } }]), n }(W), K = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = -1 === e.indexOf(this.pattern); return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] } } }], [{ key: "type", get: function () { return "inverse-exact" } }, { key: "multiRegex", get: function () { return /^!"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^!(.*)$/ } }]), n }(W), R = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = e.startsWith(this.pattern); return { isMatch: t, score: t ? 0 : 1, indices: [0, this.pattern.length - 1] } } }], [{ key: "type", get: function () { return "prefix-exact" } }, { key: "multiRegex", get: function () { return /^\^"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^\^(.*)$/ } }]), n }(W), B = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = !e.startsWith(this.pattern); return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] } } }], [{ key: "type", get: function () { return "inverse-prefix-exact" } }, { key: "multiRegex", get: function () { return /^!\^"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^!\^(.*)$/ } }]), n }(W), D = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = e.endsWith(this.pattern); return { isMatch: t, score: t ? 0 : 1, indices: [e.length - this.pattern.length, e.length - 1] } } }], [{ key: "type", get: function () { return "suffix-exact" } }, { key: "multiRegex", get: function () { return /^"(.*)"$$/ } }, { key: "singleRegex", get: function () { return /^(.*)$$/ } }]), n }(W), G = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { var t = !e.endsWith(this.pattern); return { isMatch: t, score: t ? 0 : 1, indices: [0, e.length - 1] } } }], [{ key: "type", get: function () { return "inverse-suffix-exact" } }, { key: "multiRegex", get: function () { return /^!"(.*)"$$/ } }, { key: "singleRegex", get: function () { return /^!(.*)$$/ } }]), n }(W), H = function (e) { a(n, e); var t = d(n); function n(e) { var o, c = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = c.location, a = void 0 === i ? _.location : i, s = c.threshold, u = void 0 === s ? _.threshold : s, f = c.distance, l = void 0 === f ? _.distance : f, h = c.includeMatches, d = void 0 === h ? _.includeMatches : h, v = c.findAllMatches, g = void 0 === v ? _.findAllMatches : v, y = c.minMatchCharLength, p = void 0 === y ? _.minMatchCharLength : y, m = c.isCaseSensitive, b = void 0 === m ? _.isCaseSensitive : m, M = c.ignoreLocation, k = void 0 === M ? _.ignoreLocation : M; return r(this, n), (o = t.call(this, e))._bitapSearch = new P(e, { location: a, threshold: u, distance: l, includeMatches: d, findAllMatches: g, minMatchCharLength: p, isCaseSensitive: b, ignoreLocation: k }), o } return c(n, [{ key: "search", value: function (e) { return this._bitapSearch.searchIn(e) } }], [{ key: "type", get: function () { return "fuzzy" } }, { key: "multiRegex", get: function () { return /^"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^(.*)$/ } }]), n }(W), J = function (e) { a(n, e); var t = d(n); function n(e) { return r(this, n), t.call(this, e) } return c(n, [{ key: "search", value: function (e) { for (var t, n = 0, r = [], o = this.pattern.length; ;) { if (-1 === (t = e.indexOf(this.pattern, n))) break; n = t + o, r.push([t, n - 1]) } var c = !!r.length; return { isMatch: c, score: c ? 0 : 1, indices: r } } }], [{ key: "type", get: function () { return "include" } }, { key: "multiRegex", get: function () { return /^'"(.*)"$/ } }, { key: "singleRegex", get: function () { return /^'(.*)$/ } }]), n }(W), Q = [z, J, R, B, G, D, K, H, T], U = Q.length, V = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/; function X(e, t) { for (var n = [], r = 0, o = e.length; r < o; r += 1) { var c = e[r]; if (k(c)) for (var i = c.split(V), a = 0, s = i.length; a < s; a += 1) { var u = i[a], f = !0, l = !1, h = -1; for (; f && ++h < U;) { var d = Q[h], v = d.isMultiMatch(u); v && (n.push(new d(v, t)), f = !1) } if (f) for (h = -1; ++h < U;) { var g = Q[h], y = g.isSingleMatch(u); if (y) { n.push(new g(y, t)), l = !0; break } } if (!l) { var p = u.split("|").filter((function (e) { return e.trim() })); if (p.length > 1) { var m = p.map((function (e) { return X([e], t) })); n.push({ $or: m }) } } } else n.push({ $and: X(c, t) }) } return n } var Y = new Set([H.type, J.type]), Z = function () { function e(n) { var o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c = arguments.length > 2 ? arguments[2] : void 0; if (r(this, e), this.options = t(t({}, _), o), this.options.useExtendedSearch) this._query = new E(n, this.options).query; else { this._query = X(M(n) ? n : [n], this.options) } this._keyStore = new O({ getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }), function (e) { var t = []; return M(e) ? e.forEach((function (e) { t.push.apply(t, p(Z.parseQueryConditions(e))) })) : t.push.apply(t, p(Z.parseQueryConditions(e))), t }(this._query).forEach((function (e) { c._keyStore.keys.some((function (t) { return t.id === e.keyId })) || c._keyStore.setKeys([].concat(p(c._keyStore.keys), [A(e.keyId)])) })) } return c(e, [{ key: "searchIn", value: function (e, t) { var n = this.options, r = n.ignoreFieldNorm, o = n.fieldNormWeight; return function (e, t, n, r) { var o = r.isCaseSensitive, c = r.includeMatches, i = r.minMatchCharLength, a = r.ignoreLocation, s = r.findAllMatches; if (!e || !t) return { isMatch: !1, score: 1 }; var u = t.v, f = t.n, l = C(e.toLowerCase(), u, { location: 0, distance: 1e4, threshold: .5, findAllMatches: s, minMatchCharLength: i, includeMatches: c, ignoreLocation: a, isCaseSensitive: o }); l.isMatch && (l.score *= r.ignoreFieldNorm || !f ? 1 : f * o); return l }(e, t, 0, { isCaseSensitive: this.options.isCaseSensitive, includeMatches: this.options.includeMatches, minMatchCharLength: this.options.minMatchCharLength, ignoreLocation: this.options.ignoreLocation, findAllMatches: this.options.findAllMatches, ignoreFieldNorm: r, fieldNormWeight: o }) } }, { key: "search", value: function (e) { var t = this, n = [], r = this._keyStore.keys; if (!r.length) return this._query.forEach((function (r) { var o = t._executeQuery(r, e); o.isMatch && n.push({ item: e, score: o.score, indices: o.indices }) })), n; this._query.forEach((function (o) { r.forEach((function (r) { var c = t._executeQueryForKey(o, e, r); c.isMatch && n.push({ item: e, score: c.score, indices: c.indices, key: r.id }) })) })); return n } }, { key: "_executeQuery", value: function (e, t) { if (e.$and) { for (var n = { isMatch: !0, score: 0, indices: [] }, r = 0; r < e.$and.length; r += 1) { var o = e.$and[r], c = this._executeQuery(o, t); if (!c.isMatch) return { isMatch: !1, score: 1 }; n.score += c.score, c.indices && (n.indices = n.indices.concat(c.indices)) } return n.score /= e.$and.length, n } if (e.$or) { for (var i = { isMatch: !1, score: 1, indices: [] }, a = 0; a < e.$or.length; a += 1) { var s = e.$or[a], u = this._executeQuery(s, t); if (u.isMatch) { i.isMatch = !0, i.score = Math.min(i.score, u.score), u.indices && (i.indices = i.indices.concat(u.indices)) } } return i } return this._executeSingleQuery(e, t) } }, { key: "_executeQueryForKey", value: function (e, t, n) { if (e.$and) { for (var r = { isMatch: !0, score: 0, indices: [] }, o = 0; o < e.$and.length; o += 1) { var c = e.$and[o], i = this._executeQueryForKey(c, t, n); if (!i.isMatch) return { isMatch: !1, score: 1 }; r.score += i.score, i.indices && (r.indices = r.indices.concat(i.indices)) } return r.score /= e.$and.length, r } if (e.$or) { for (var a = { isMatch: !1, score: 1, indices: [] }, s = 0; s < e.$or.length; s += 1) { var u = e.$or[s], f = this._executeQueryForKey(u, t, n); if (f.isMatch) { a.isMatch = !0, a.score = Math.min(a.score, f.score), f.indices && (a.indices = a.indices.concat(f.indices)) } } return a } return this._executeSingleQueryForKey(e, t, n) } }, { key: "_executeSingleQuery", value: function (e, t) { if (!k(t)) return { isMatch: !1, score: 1 }; var n; return "string" == typeof e ? n = this._executeSingleCondition(e, { v: t }) : e.$fuzzy ? n = this.searchIn(e.$fuzzy, { v: t }) : e.$exact ? n = new z(e.$exact).search(t) : e.$prefix ? n = new R(e.$prefix).search(t) : e.$suffix ? n = new D(e.$suffix).search(t) : n = { isMatch: !1, score: 1 }, { isMatch: n.isMatch, score: n.isMatch ? n.score : 1, indices: n.indices } } }, { key: "_executeSingleQueryForKey", value: function (e, t, n) { var r = this._keyStore.getValueForItemAtKeyId(t, n.id); if (!L(r)) return { isMatch: !1, score: 1 }; if (M(r)) { for (var o = { isMatch: !1, score: 1, indices: [] }, c = 0; c < r.length; c += 1) { var i = r[c], a = this._executeSingleCondition(e, i); if (a.isMatch) { o.isMatch = !0, o.score = Math.min(o.score, a.score), a.indices && (o.indices = o.indices.concat(a.indices)) } } return o } return this._executeSingleCondition(e, r) } }, { key: "_executeSingleCondition", value: function (e, t) { return "string" == typeof e ? this.searchIn(e, t) : e.$fuzzy ? this.searchIn(e.$fuzzy, t) : e.$exact ? new z(e.$exact).search(t.v) : e.$prefix ? new R(e.$prefix).search(t.v) : e.$suffix ? new D(e.$suffix).search(t.v) : { isMatch: !1, score: 1 } } }], [{ key: "parseQueryConditions", value: function (e) { var t = []; return "string" == typeof e ? t.push({ keyId: null, query: e }) : e.$and ? e.$and.forEach((function (e) { t.push.apply(t, p(Z.parseQueryConditions(e))) })) : e.$or ? e.$or.forEach((function (e) { t.push.apply(t, p(Z.parseQueryConditions(e))) })) : Object.keys(e).forEach((function (n) { t.push({ keyId: n, query: e[n] }) })), t } }]), e }(); function ee(e, n) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o = r.includeMatches, c = void 0 === o ? _.includeMatches : o, i = r.includeScore, a = void 0 === i ? _.includeScore : i, s = []; return c && s.push((function (e) { var t = e.matches; e.matches = void 0, t && (e.matches = [], t.forEach((function (t) { if (t.indices && t.indices.length) { var n = { indices: t.indices, value: t.value }; t.key && (n.key = t.key.src), t.idx > -1 && (n.refIndex = t.idx), e.matches.push(n) } }))) })), a && s.push((function (e) { e.score = e.score })), function (e, n, r) { return r.length ? r.reduce((function (r, o) { return n.forEach((function (n) { var c = e.get(n); c || (c = { idx: n, item: null, matches: [] }, e.set(n, c)), o(c, r) })), r }), e) : e }(new Map, n, s).forEach((function (n) { var r = n.idx, o = n.item, c = n.score, i = n.matches, a = { item: o, refIndex: r }; c && (a.score = c), i && (a.matches = i), e.push(a) })), e.sort((function (e, n) { return e.score - n.score || e.refIndex - n.refIndex })), e } var te = function () { function e(n) { var o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, c = arguments.length > 2 ? arguments[2] : void 0; r(this, e), this.options = t(t({}, _), o), this._keyStore = new O({ getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }), this.setCollection(n, c) } return c(e, [{ key: "setCollection", value: function (e, t) { if (this._docs = e, t && !(t instanceof O)) throw new Error("Incorrect 'index' type"); this._myIndex = t || j(this._keyStore.keys, this._docs, { getFn: this.options.getFn, fieldNormWeight: this.options.fieldNormWeight }) } }, { key: "add", value: function (e) { L(e) && (this._docs.push(e), this._myIndex.add(e)) } }, { key: "remove", value: function (e) { for (var t = [], n = 0, r = this._docs.length; n < r; n += 1) { var o = this._docs[n]; e(o, n) && (this.removeAt(n), n -= 1, r -= 1, t.push(o)) } return t } }, { key: "removeAt", value: function (e) { this._docs.splice(e, 1), this._myIndex.removeAt(e) } }, { key: "getIndex", value: function () { return this._myIndex } }, { key: "search", value: function (e) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = n.limit, o = void 0 === r ? -1 : r, c = this.options, i = c.includeMatches, a = c.includeScore, s = c.shouldSort, u = c.sortFn, f = c.ignoreFieldNorm, l = k(e) ? k(this._docs[0]) ? this._searchStringList(e) : this._searchObjectList(e) : this._searchLogical(e); return function (e) { var t = e.ignoreFieldNorm; e.results.forEach((function (e) { e.score = (n = e.matches, n.reduce((function (e, n) { return e + n.score }), 0) / n.length); var n })) }({ results: l, ignoreFieldNorm: f }), s && l.sort(u), S(o) && o > -1 && (l = l.slice(0, o)), ee([], l, { includeMatches: i, includeScore: a }) } }, { key: "_searchStringList", value: function (e) { var t = new P(e, this.options), n = this._myIndex.records, r = []; return n.forEach((function (e) { var n = e.v, o = e.i, c = e.n; if (L(n)) { var i = t.searchIn(n); i.isMatch && r.push({ item: n, idx: o, matches: [{ score: i.score, value: n, norm: c, indices: i.indices }] }) } })), r } }, { key: "_searchLogical", value: function (e) { var t = this, n = new Z(e, this.options, this), r = this._myIndex.records, o = {}, c = []; return r.forEach((function (e) { var r = e.i, i = e.$, a = n.search(i); a.length && (o[r] || (o[r] = { idx: r, item: i, matches: [] }, c.push(o[r])), a.forEach((function (e) { var n = e.key; o[r].matches.push({ score: e.score, key: n, value: t._keyStore.getValueForItemAtKeyId(i, n), indices: e.indices }) }))) })), c } }, { key: "_searchObjectList", value: function (e) { var n = this, r = new P(e, this.options), o = this._myIndex, c = o.keys, i = o.records, a = []; return i.forEach((function (e) { var o = e.$, i = e.i; if (L(o)) { var s = []; c.forEach((function (e, c) { s.push.apply(s, p(n._findMatches({ key: e, value: o[c], searcher: r }))) })), s.length && a.push({ idx: i, item: o, matches: s }) } })), a } }, { key: "_findMatches", value: function (e) { var n = e.key, r = e.value, o = e.searcher; if (!L(r)) return []; if (M(r)) { for (var c = [], i = 0, a = r.length; i < a; i += 1) { var s = r[i], u = s.v, f = s.i, l = s.n; if (L(u)) { var h = o.searchIn(u); h.isMatch && c.push({ score: h.score, key: n, value: u, idx: f, norm: l, indices: h.indices }) } } return c } var d = r.v, v = r.n, g = o.searchIn(d); return g.isMatch ? [{ score: g.score, key: n, value: d, norm: v, indices: g.indices }] : [] } }]), e }(); return te.version = "6.6.2", te.createIndex = j, te.parseIndex = function (e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t.getFn, r = void 0 === n ? _.getFn : n, o = t.fieldNormWeight, c = void 0 === o ? _.fieldNormWeight : o, i = e.keys, a = e.records, s = new O({ getFn: r, fieldNormWeight: c }); return s.setKeys(i), s.setIndexRecords(a), s }, te.config = _, function () { Q.push.apply(Q, arguments) }(Z), te
}));
