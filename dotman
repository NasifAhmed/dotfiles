#!/usr/bin/env bash

# ╔═══════════════════════════════════════════════════════════════════════════╗
# ║                           DOTMAN - Dotfiles Manager                        ║
# ║            A TUI-based dotfiles manager using GNU Stow and fzf            ║
# ╚═══════════════════════════════════════════════════════════════════════════╝

set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Configuration
# ─────────────────────────────────────────────────────────────────────────────
# Resolve the actual script location (follows symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [[ -L "$SCRIPT_PATH" ]]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ "$SCRIPT_PATH" != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
SCRIPT_NAME="$(basename "$SCRIPT_PATH")"

REPO_DIR="$SCRIPT_DIR/repo"
TARGET_DIR="$HOME"
LOCAL_BIN="$HOME/.local/bin"

# ─────────────────────────────────────────────────────────────────────────────
# Colors and Formatting
# ─────────────────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# ─────────────────────────────────────────────────────────────────────────────
# UI Helper Functions
# ─────────────────────────────────────────────────────────────────────────────
success() { echo -e "${GREEN}✓${NC} $1"; }
error() { echo -e "${RED}✗${NC} $1"; }
warning() { echo -e "${YELLOW}⚠${NC} $1"; }
info() { echo -e "${BLUE}ℹ${NC} $1"; }
header() { echo -e "\n${BOLD}${CYAN}══ $1 ══${NC}\n"; }

# Spinner for loading animation
spinner_pid=""
start_spinner() {
    local msg="$1"
    local chars="⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
    (
        while true; do
            for ((i = 0; i < ${#chars}; i++)); do
                printf "\r${CYAN}%s${NC} %s" "${chars:$i:1}" "$msg"
                sleep 0.1
            done
        done
    ) &
    spinner_pid=$!
    disown
}

stop_spinner() {
    if [[ -n "$spinner_pid" ]]; then
        kill "$spinner_pid" 2>/dev/null || true
        wait "$spinner_pid" 2>/dev/null || true
        spinner_pid=""
        printf "\r\033[K"  # Clear line
    fi
}

# Cleanup on exit
cleanup() {
    stop_spinner
}
trap cleanup EXIT

# ─────────────────────────────────────────────────────────────────────────────
# Dependency Checking
# ─────────────────────────────────────────────────────────────────────────────
check_dependencies() {
    header "Checking Dependencies"
    local missing=()
    
    for cmd in stow git fzf; do
        if command -v "$cmd" &>/dev/null; then
            success "$cmd is installed"
        else
            error "$cmd is NOT installed"
            missing+=("$cmd")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        echo ""
        error "Missing dependencies: ${missing[*]}"
        echo -e "${YELLOW}Please install them and run again.${NC}"
        exit 1
    fi
    
    # Check hyprpm for hyprland-plugins (optional)
    if command -v hyprpm &>/dev/null; then
        start_spinner "Setting up hyprland-plugins..."
        if ! hyprpm list 2>/dev/null | grep -q "hyprscrolling"; then
            hyprpm add https://github.com/hyprwm/hyprland-plugins 2>/dev/null || true
            hyprpm enable hyprscrolling 2>/dev/null || true
        fi
        stop_spinner
        success "hyprpm configured"
    fi
    
    # Check PATH for ~/.local/bin
    check_local_bin_path
    
    # Symlink dotman to ~/.local/bin for global access
    setup_dotman_symlink
    
    echo ""
    success "All dependencies satisfied!"
    sleep 1
}

check_local_bin_path() {
    if [[ ":$PATH:" != *":$LOCAL_BIN:"* ]]; then
        warning "$LOCAL_BIN is not in PATH"
        
        # Detect shell and rc file
        local shell_rc=""
        case "$SHELL" in
            */bash) shell_rc="$HOME/.bashrc" ;;
            */zsh)  shell_rc="$HOME/.zshrc" ;;
            */fish) shell_rc="$HOME/.config/fish/config.fish" ;;
            *)      shell_rc="$HOME/.profile" ;;
        esac
        
        if [[ -f "$shell_rc" ]]; then
            if ! grep -q "export PATH=.*$LOCAL_BIN" "$shell_rc" 2>/dev/null; then
                echo "" >> "$shell_rc"
                echo "# Added by dotman" >> "$shell_rc"
                echo "export PATH=\"$LOCAL_BIN:\$PATH\"" >> "$shell_rc"
                success "Added $LOCAL_BIN to $shell_rc"
                info "Run 'source $shell_rc' or restart shell to apply"
            fi
        fi
    else
        success "$LOCAL_BIN is in PATH"
    fi
}

setup_dotman_symlink() {
    local symlink_path="$LOCAL_BIN/dotman"
    local script_full_path="$SCRIPT_DIR/$SCRIPT_NAME"
    
    # Ensure ~/.local/bin exists
    mkdir -p "$LOCAL_BIN"
    
    # Check if symlink already exists and points to correct location
    if [[ -L "$symlink_path" ]]; then
        local current_target
        current_target=$(readlink -f "$symlink_path" 2>/dev/null || echo "")
        if [[ "$current_target" == "$script_full_path" ]]; then
            success "dotman symlink OK"
            return
        else
            # Remove old symlink
            rm -f "$symlink_path"
        fi
    elif [[ -e "$symlink_path" ]]; then
        # Regular file exists, back it up
        mv "$symlink_path" "${symlink_path}.bak"
        warning "Backed up existing dotman to dotman.bak"
    fi
    
    # Create symlink
    ln -sf "$script_full_path" "$symlink_path"
    success "Symlinked dotman to $LOCAL_BIN"
}

# ─────────────────────────────────────────────────────────────────────────────
# Package Management Functions
# ─────────────────────────────────────────────────────────────────────────────
get_packages() {
    find "$REPO_DIR" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort
}

# Simplified conflict resolution for stow - preserves tree folding
# Only handles: existing files and foreign symlinks that block stow
# Does NOT create directories - let stow handle tree folding naturally
resolve_all_conflicts() {
    local pkg="$1"
    local pkg_dir="$REPO_DIR/$pkg"
    
    # Only process FILES in the package (not directories)
    # This preserves stow's tree folding behavior
    while IFS= read -r -d '' item; do
        local rel_path="${item#$pkg_dir/}"
        local target="$TARGET_DIR/$rel_path"
        
        # Skip .stow-folder marker if present
        [[ "$(basename "$item")" == ".stow-folder" ]] && continue
        
        # Only handle if target exists as a file or symlink (not directory)
        if [[ -L "$target" ]]; then
            # It's a symlink
            local link_target
            link_target=$(readlink -f "$target" 2>/dev/null || echo "")
            
            # Check if it points to our repo - remove to allow re-stow
            if [[ "$link_target" == "$REPO_DIR"* ]]; then
                rm -f "$target"
            else
                # Foreign symlink - remove it
                rm -f "$target"
            fi
        elif [[ -f "$target" ]]; then
            # Regular file exists - backup it
            local backup="${target}.bak"
            local counter=1
            while [[ -e "$backup" ]]; do
                backup="${target}.bak.${counter}"
                ((counter++)) || true
            done
            mv "$target" "$backup"
            warning "Backed up: $rel_path → $(basename "$backup")"
        fi
        # If target is a directory, let stow handle it (tree folding will work)
    done < <(find "$pkg_dir" -type f -print0)
    
    return 0
}

# Clean stow with verbose error handling
stow_package() {
    local pkg="$1"
    local pkg_dir="$REPO_DIR/$pkg"
    
    if [[ ! -d "$pkg_dir" ]]; then
        error "Package '$pkg' not found"
        return 1
    fi
    
    # First, try a dry-run to check for conflicts
    local stow_output
    stow_output=$(stow -d "$REPO_DIR" -t "$TARGET_DIR" -n -v "$pkg" 2>&1) || true
    
    if echo "$stow_output" | grep -q "would cause conflicts\|CONFLICT\|cannot stow"; then
        # Conflicts detected - resolve them
        info "Resolving conflicts for $pkg..."
        resolve_all_conflicts "$pkg"
    fi
    
    # Now try to stow
    start_spinner "Stowing $pkg..."
    
    local result
    result=$(stow -d "$REPO_DIR" -t "$TARGET_DIR" "$pkg" 2>&1) || true
    
    # Check if stow succeeded (no error output or only warnings)
    if echo "$result" | grep -qi "error\|cannot stow\|conflict"; then
        stop_spinner
        error "Failed to stow: $pkg"
        echo "$result" | head -5
        return 1
    else
        stop_spinner
        success "Stowed: $pkg"
        return 0
    fi
}

# Force stow - resolve any conflicts and retry multiple times
force_stow_package() {
    local pkg="$1"
    local max_attempts=3
    local attempt=1
    
    while [[ $attempt -le $max_attempts ]]; do
        # Check current state
        local stow_check
        stow_check=$(stow -d "$REPO_DIR" -t "$TARGET_DIR" -n "$pkg" 2>&1) || true
        
        if [[ -z "$stow_check" ]]; then
            # No conflicts, stow it
            if stow -d "$REPO_DIR" -t "$TARGET_DIR" "$pkg" 2>/dev/null; then
                success "Stowed: $pkg"
                return 0
            fi
        fi
        
        # Conflicts exist - resolve them
        resolve_all_conflicts "$pkg"
        ((attempt++)) || true
    done
    
    # Final attempt with --adopt (adopts existing files into stow)
    if stow -d "$REPO_DIR" -t "$TARGET_DIR" --adopt "$pkg" 2>/dev/null; then
        success "Stowed (adopted): $pkg"
        return 0
    fi
    
    error "Failed to stow after $max_attempts attempts: $pkg"
    return 1
}

unstow_package() {
    local pkg="$1"
    
    start_spinner "Unstowing $pkg..."
    
    # Try normal unstow first
    if stow -d "$REPO_DIR" -t "$TARGET_DIR" -D "$pkg" 2>/dev/null; then
        stop_spinner
        success "Unstowed: $pkg"
        return 0
    fi
    
    stop_spinner
    
    # If normal unstow fails, manually remove symlinks
    local pkg_dir="$REPO_DIR/$pkg"
    local removed=0
    
    while IFS= read -r -d '' file; do
        local rel_path="${file#$pkg_dir/}"
        local target="$TARGET_DIR/$rel_path"
        
        if [[ -L "$target" ]]; then
            local link_target
            link_target=$(readlink -f "$target" 2>/dev/null || echo "")
            # Only remove if it points to our repo
            if [[ "$link_target" == "$pkg_dir"* ]]; then
                rm -f "$target"
                ((removed++)) || true
            fi
        fi
    done < <(find "$pkg_dir" -type f -print0)
    
    if [[ $removed -gt 0 ]]; then
        success "Unstowed: $pkg (removed $removed symlinks)"
        return 0
    else
        warning "Nothing to unstow for: $pkg"
        return 0
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Menu Actions
# ─────────────────────────────────────────────────────────────────────────────
action_sync() {
    header "Git Sync"
    cd "$SCRIPT_DIR"
    
    # Step 1: Commit local changes FIRST if any exist (NO STASHING - breaks Hyprland)
    if ! git diff --quiet 2>/dev/null || ! git diff --cached --quiet 2>/dev/null || [[ -n "$(git status --porcelain)" ]]; then
        start_spinner "Committing local changes..."
        git add -A
        local commit_msg="sync: $(date '+%Y-%m-%d %H:%M:%S')"
        git commit -m "$commit_msg" >/dev/null 2>&1 || true
        stop_spinner
        success "Committed: $commit_msg"
    fi
    
    # Step 2: Pull with cloud version preferred on conflicts
    start_spinner "Pulling from remote..."
    
    local pull_output
    if pull_output=$(git pull -X theirs 2>&1); then
        stop_spinner
        success "Pulled latest changes"
    else
        stop_spinner
        # Check if it's a conflict that couldn't be resolved
        if echo "$pull_output" | grep -qi "conflict\|merge\|failed"; then
            warning "Pull had conflicts, accepting cloud version..."
            # Hard reset to remote for unresolvable conflicts
            git fetch origin
            git reset --hard origin/$(git branch --show-current)
            success "Reset to cloud version"
        else
            error "Pull failed: $pull_output"
            echo ""
            read -rp "Press Enter to continue..."
            return 1
        fi
    fi
    
    # Step 3: Push (our commit + any merge commit)
    start_spinner "Pushing to remote..."
    if git push 2>/dev/null; then
        stop_spinner
        success "Changes pushed"
    else
        stop_spinner
        # Check if there's nothing to push
        if git diff --quiet origin/$(git branch --show-current) 2>/dev/null; then
            info "Already up to date"
        else
            warning "Push failed - check remote"
        fi
    fi
    
    echo ""
    read -rp "Press Enter to continue..."
}

action_stow_all() {
    header "Stow All Packages"
    
    local packages
    packages=$(get_packages)
    
    if [[ -z "$packages" ]]; then
        warning "No packages found in $REPO_DIR"
        read -rp "Press Enter to continue..."
        return
    fi
    
    echo "$packages" | while read -r pkg; do
        stow_package "$pkg"
    done
    
    echo ""
    success "All packages processed!"
    read -rp "Press Enter to continue..."
}

action_stow_selective() {
    header "Stow Selective"
    
    local packages
    packages=$(get_packages)
    
    if [[ -z "$packages" ]]; then
        warning "No packages found in $REPO_DIR"
        read -rp "Press Enter to continue..."
        return
    fi
    
    local selected
    selected=$(echo "$packages" | fzf --prompt="Select package to stow > " \
        --header="Use Enter to select, Esc to go back" \
        --preview="tree -C $REPO_DIR/{} 2>/dev/null || ls -la $REPO_DIR/{}" \
        --preview-window=right:50%) || true
    
    if [[ -n "$selected" ]]; then
        stow_package "$selected"
        echo ""
        read -rp "Press Enter to continue..."
    fi
}

action_unstow_all() {
    header "Unstow All Packages"
    
    local packages
    packages=$(get_packages)
    
    if [[ -z "$packages" ]]; then
        warning "No packages found in $REPO_DIR"
        read -rp "Press Enter to continue..."
        return
    fi
    
    echo "$packages" | while read -r pkg; do
        unstow_package "$pkg"
    done
    
    echo ""
    success "All packages unstowed!"
    read -rp "Press Enter to continue..."
}

action_unstow_selective() {
    header "Unstow Selective"
    
    local packages
    packages=$(get_packages)
    
    if [[ -z "$packages" ]]; then
        warning "No packages found in $REPO_DIR"
        read -rp "Press Enter to continue..."
        return
    fi
    
    local selected
    selected=$(echo "$packages" | fzf --prompt="Select package to unstow > " \
        --header="Use Enter to select, Esc to go back" \
        --preview="tree -C $REPO_DIR/{} 2>/dev/null || ls -la $REPO_DIR/{}" \
        --preview-window=right:50%) || true
    
    if [[ -n "$selected" ]]; then
        unstow_package "$selected"
        echo ""
        read -rp "Press Enter to continue..."
    fi
}

action_add_to_repo() {
    header "Add to Repository"
    
    # Get path from user
    echo -e "${CYAN}Enter the path to add (file or folder):${NC}"
    echo -e "${DIM}Example: ~/.config/nvim or ~/Documents/myfile.txt${NC}"
    echo ""
    read -rp "> " input_path
    
    if [[ -z "$input_path" ]]; then
        warning "No path entered"
        read -rp "Press Enter to continue..."
        return
    fi
    
    # Expand ~ and resolve path
    local selected
    selected=$(eval echo "$input_path")
    
    # Check if path exists
    if [[ ! -e "$selected" ]]; then
        error "Path does not exist: $selected"
        read -rp "Press Enter to continue..."
        return
    fi
    
    # Show what was found
    if [[ -d "$selected" ]]; then
        info "Found directory: $selected"
    else
        info "Found file: $selected"
    fi
    echo ""
    
    # Ask for package name
    echo -e "${CYAN}Enter package name:${NC}"
    read -rp "> " pkg_name
    
    if [[ -z "$pkg_name" ]]; then
        error "Package name cannot be empty"
        read -rp "Press Enter to continue..."
        return
    fi
    
    # Check if package already exists
    local pkg_dir="$REPO_DIR/$pkg_name"
    if [[ -d "$pkg_dir" ]]; then
        warning "Package '$pkg_name' already exists"
        read -rp "Add to existing package? (y/N): " confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            info "Cancelled"
            read -rp "Press Enter to continue..."
            return
        fi
    fi
    
    # Calculate relative path from home
    local rel_path="${selected#$HOME/}"
    local target_dir="$pkg_dir/$(dirname "$rel_path")"
    
    start_spinner "Adding to repository..."
    
    # Create directory structure
    mkdir -p "$target_dir"
    
    # Move file/folder to repo
    mv "$selected" "$target_dir/"
    
    stop_spinner
    success "Added: $selected → $pkg_dir"
    
    # Stow it back
    stow_package "$pkg_name"
    
    # Git add
    cd "$SCRIPT_DIR"
    git add -A
    success "Ready to sync"
    
    echo ""
    read -rp "Press Enter to continue..."
}

action_remove_from_repo() {
    header "Remove from Repository"
    
    local packages
    packages=$(get_packages)
    
    if [[ -z "$packages" ]]; then
        warning "No packages found in $REPO_DIR"
        read -rp "Press Enter to continue..."
        return
    fi
    
    local selected
    selected=$(echo "$packages" | fzf --prompt="Select package to remove > " \
        --header="WARNING: This will restore files and delete package. Esc to go back" \
        --preview="tree -C $REPO_DIR/{} 2>/dev/null || ls -la $REPO_DIR/{}" \
        --preview-window=right:50%) || true
    
    if [[ -z "$selected" ]]; then
        return
    fi
    
    # Confirm
    echo ""
    read -rp "Are you sure you want to remove '$selected'? (y/N): " confirm
    if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
        info "Cancelled"
        return
    fi
    
    start_spinner "Removing package..."
    
    # First unstow
    stow -d "$REPO_DIR" -t "$TARGET_DIR" -D "$selected" 2>/dev/null || true
    
    # Move files back to their original locations
    local pkg_dir="$REPO_DIR/$selected"
    while IFS= read -r -d '' file; do
        local rel_path="${file#$pkg_dir/}"
        local target="$TARGET_DIR/$rel_path"
        local target_dir="$(dirname "$target")"
        
        mkdir -p "$target_dir"
        cp -r "$file" "$target"
    done < <(find "$pkg_dir" -type f -print0)
    
    # Remove from repo
    rm -rf "$pkg_dir"
    
    stop_spinner
    success "Removed package: $selected"
    
    # Git
    cd "$SCRIPT_DIR"
    git add -A
    success "Ready to sync"
    
    echo ""
    read -rp "Press Enter to continue..."
}

action_history() {
    header "Git History"
    
    cd "$SCRIPT_DIR"
    
    local selected
    selected=$(git log --oneline --color=always -50 | \
        fzf --ansi --prompt="Git History > " \
            --header="View commits. Esc to go back" \
            --preview="git show --color=always {1}" \
            --preview-window=right:60%) || true
    
    if [[ -n "$selected" ]]; then
        local commit_hash
        commit_hash=$(echo "$selected" | awk '{print $1}')
        git show --color=always "$commit_hash" | less -R
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Main Menu
# ─────────────────────────────────────────────────────────────────────────────
show_main_menu() {
    local options="󰓦  Sync (Pull & Push)
󰆓  Stow All
󰆓  Stow Selective
󰆴  Unstow All
󰆴  Unstow Selective
󰐕  Add to Repo
󰍴  Remove from Repo
󰋚  History
󰩈  Exit"

    echo "$options" | fzf --prompt="DOTMAN > " \
        --header="$(echo -e "${BOLD}Dotfiles Manager${NC} | Repo: $(get_packages | wc -l) packages")" \
        --no-info \
        --ansi \
        --cycle \
        --color="header:italic"
}

main() {
    # Check dependencies on first run
    check_dependencies
    
    clear
    
    while true; do
        local choice
        choice=$(show_main_menu) || true
        
        case "$choice" in
            *"Sync"*)          action_sync ;;
            *"Stow All"*)      action_stow_all ;;
            *"Stow Selective"*) action_stow_selective ;;
            *"Unstow All"*)    action_unstow_all ;;
            *"Unstow Selective"*) action_unstow_selective ;;
            *"Add to Repo"*)   action_add_to_repo ;;
            *"Remove from Repo"*) action_remove_from_repo ;;
            *"History"*)       action_history ;;
            *"Exit"*|"")       
                echo -e "\n${GREEN}Goodbye!${NC}"
                exit 0
                ;;
        esac
        
        clear
    done
}

# ─────────────────────────────────────────────────────────────────────────────
# Run
# ─────────────────────────────────────────────────────────────────────────────
main "$@"
